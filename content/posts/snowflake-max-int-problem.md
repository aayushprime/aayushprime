---
title: "Where are my bits getting lost?"
date: 2025-04-02T20:29:33+05:45
draft: false
searchHidden: false
ShowBreadCrumbs: false
ShowToc: true
TocOpen: true
cover:
  image: "/posts/snowflake-max-int-problem/thumb.png"
  alt: "Failed image loading"
  caption: ""
  relative: false # To use relative path for cover image, used in hugo Page-bundles
  linkFullImages: true
  responsiveImages: false
---

Today I was trying to implement the Snowflake Id generator for [Fly.io Gossip Glomers](https://fly.io/dist-sys/) second challenge, `Unique Id` generation.
Here's what I came up with.

```go
package main

import (
	"encoding/json"
	"log"
	"strconv"
	"time"

	maelstrom "github.com/jepsen-io/maelstrom/demo/go"
)

type Snowflake struct {
	sequenceNumber uint64
	selfId         int
	lastTs         int64
}

func nextId(s *Snowflake) uint64 {
	ts := time.Now().UnixMilli() // this is 41 bits
	if s.lastTs == ts {
		s.sequenceNumber++
	} else {
		s.sequenceNumber = 0
	}
	s.lastTs = ts
	var id uint64 = uint64(ts << 22) // (64 - 1 sign bit - 41 unix timestamp bits)
	log.Printf("shifted %d", id)
	id = id | ((uint64(s.selfId) & 0x3f) << 16) // machine id is 10 bits
	log.Printf("after self Id %d", id)
	id = id | ((s.sequenceNumber & 0xffff) )
	return id
}

func main() {

	n := maelstrom.NewNode()

	sf := &Snowflake{}
	n.Handle("generate", func(msg maelstrom.Message) error {

		var body map[string]any
		if err := json.Unmarshal(msg.Body, &body); err != nil {
			return err
		}

		selfId, err := strconv.Atoi(msg.Dest[1:])
		if err != nil {
			log.Fatal("Cannot parse destination as a number", msg.Dest)
		}
		sf.selfId = selfId

		body["type"] = "generate_ok"
		body["id"] = nextId(sf)

		return n.Reply(msg, body)
	})

	if err := n.Run(); err != nil {
		log.Fatal(err)
	}

}

```

It wasn't too bad for how simple its supposed to be. My solution wasn't getting accepted by `maelstrom` because there were duplicate Ids generated by my program. After looking at my code for very long and not finding any idea what went wrong, I asked ChatGPT, it suggested the `sequenceNumber` bits were too few and must probably be overflowing. After looking at the maelstrom logs I found the lines which had duplicate Ids.

That was very strange. I noticed all IDs generated ended with `000`. Surely, I made a mistake on the bitwise OR of the sequence number, right?

Wrong.

I figured out how to log to `stderr` and looked at what my Ids were.

```go
	id = id | ((s.sequenceNumber & 0xffff) )
	log.Printf("Sequence Number: %d %u %lu", id, id, id)
```

And they were unique alright. For a second I thought that Golang must be casting my Ids into some other datatype and truncating my IDs. But that was not it. It was `maelstrom` it wouldn't accept the last 3 digits. I think this is because we're using JSON and while JSON doesn't limit the size of the number in its spec (see [here](https://stackoverflow.com/questions/13502398/json-integers-limit-on-size)), there might be something in the middle that cannot accept that number and is thus being truncated. NodeJS for example can only process numbers upto

```js
> Number.MAX_SAFE_INTEGER
9007199254740991
>
```

So the solution is to just move the sequenceNumber a few bits up as we have plenty of space left in the sequenceNumber space. `maelstrom` test cases dont generate too many ids in the same millisecond.

```go
	id = id | ((s.sequenceNumber & 0xffff) << 10)
```
